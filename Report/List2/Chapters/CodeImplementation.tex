\section{Code Implementation} \label{sec:code-implementation}
In this section, a brief explanation of how the numerical integration methods are implemented. The code is written in Python, and a total of six classes are developed, besides the main function file. Although parts of the code are presented here, the complete code is available on the GitHub repository, which can be found in the Appendix \ref{sec:github}.

\subsection{Main File}
The main function is responsible for structuring the code and creating objects for numerical integration analysis. An example of implementation for the main function is shown in Code \ref{code:main}.
\begin{lstlisting}[language=Python, caption={Main function.}, label={code:main}] 
def main()->None:
    n_divisions = 2
    npoints = 4
    interval = Interval(0.0, 1.0, n_divisions, npoints)

    # defining the refinement level
    ref_level = 2

    # defining the function and its exact solution
    p = 1
    func = lambda x: x ** p
    exact = lambda x: 1/(p + 1) * x ** (p + 1)

    # setting the integration rule
    interval.SetGaussLegendreRule()

    # integrating the function
    interval.NumericalIntegrate(func, ref_level)
    
    # computing the error
    interval.SetExactSolution(exact, ref_level)
    interval.ComputeError()
\end{lstlisting}

In line 1 the Interval class is imported, and in line 7 an object of this class is created. As input, it takes the limits of the interval (in this case $0$ and $1$), the number of divisions, and the number of integration points. 

The function to be integrated is then defined. Here, is shown the polynomial $x$, and its exact solution, $0.5x^2$. The integration rule is set in line 18, and the function is integrated in line 21. In this example, it is used the Gauss-Legendre integration rule. 

The exact solution is set in line 24, and the error is computed in line 25. The results can also be printed in a \texttt{.txt} file, which is not presented here.

\subsection{Interval Class}
The Interval class was developed by Giovane Avancini. However, a few modifictations were made to adapt it to the project's structure. This is the main class of this work, responsible for dealing with the interval data structure and computing the numerical integration.

The fields from the Interval class are shown in Code \ref{code:Interval_fields}. Note that, since the dataclass decorator is used, the fields are automatically initialized in the constructor, not being necessary to define it explicitly.
\begin{lstlisting}[language=python, caption={Interval class fields.}, label={code:Interval_fields}]
from dataclasses import dataclass

@dataclass
class Interval:
    total_error: ClassVar[float] = 0.0
    _a: float
    _b: float
    _n_refinements: int
    _refinement_level: int = field(default=0)
    _n_points: int = field(default=0)
    _method: IntegrationRule = field(init=False, default=None)
    _sub_intervals: list = field(init=False, default_factory=list)
    _numerical_integral: float = field(init=False, default=0.0)
    _analytic_integral: float = field(init=False, default=0.0)
    _integration_error: float = field(init=False, default=0.0)
\end{lstlisting}

The floats $a$ and $b$ represents the integration interval, $n\_refinement$ is the number of refinements that is going to be made, and ${refinement\_level}$ is the current interval refinement level. The $n\_points$ variable is the number of points used in the numerical integration (mostly used in the Gauss-Legendre rule). A class variable, $total\_error$, is used to store the integration total error.

From the $method$ field on, the fields are not initialized at the moment of the object creation, which explains the \texttt{init=False} argument. The $method$ field is an object from the IntegrationRule class, $sub\_intervals$ is a list that might contain the interval subdivisions, $numerical\_integral$ is the result of the numerical integration, $analytic\_integral$ is the exact solution, and the error between the numerical and the exact solution is stored in $integration\_error$.

Among the methods of the Interval class, one stands out: the NumericalIntegrate method. This method computes the numerical integration of a given function. The code for this method is shown in Code \ref{code:NumericalIntegrate}. 
\begin{lstlisting}[language=python, caption={NumericalIntegrate Method.}, label={code:NumericalIntegrate}]
def NumericalIntegrate(self, func: callable, ref_level: int = 0)->float:
    self.numerical_integral = 0.0
    if self.refinement_level == ref_level:
        self.numerical_integral = self.method.Integrate(func, self.a, self.b, self.n_points)
    else:
        for interval in self.sub_intervals:
            self.numerical_integral += interval.NumericalIntegrate(func, ref_level)

    return self.numerical_integral
\end{lstlisting}

Line 3 checks if the current interval is the one that the numerical integration is going to be computed. If it is, the method Integrate from the IntegrationRule class is called. Otherwise, the method is called recursively for each subinterval.

Finally, the ComputeError method (Code \ref{code:ComputeError}) is responsible for computing the error between the numerical and the exact solution.
\begin{lstlisting}[language=python, caption={ComputeError Method}, label={code:ComputeError}]
def ComputeError(self)->None:
    if ref_level == 0:
        self.integration_error = abs(self.analytic_integral - self.numerical_integral)
        Interval.total_error += self.integration_error

    interval: Interval
    for interval in self.sub_intervals:
        if interval.refinement_level == ref_level: 
            interval.integration_error = abs(self.analytic_integral - self.numerical_integral)
            Interval.total_error += interval.integration_error

        interval.ComputeError(ref_level)
\end{lstlisting}

Note that there is a difference between the variable $interval$ and the class $Interval$. To be able to access the variable class $total\_error$, the class name is used.

\subsection{IntegrationRule Class}
The IntegrationRule class is what it's called an \textit{abstract class}. It is a class that cannot be instantiated, but it is used as a base class for other classes. In this case, it is used as a base class for the numerical integration rule classes. 

As its abstract methods, one cite the IntegrationPoints method, in which the integration points are computed, the Xmap method, which maps the integration points to the interval, and the DetJac method, which computes the Jacobian determinant. An observation is made at this point. The methods' names might not be appropriate for the one-third and three-eighths Simpson, and the Trapezoidal rules. However, the names come from the ones employed in Gauss-Legendre implementations. 

This class takes in advantage the fact that, for all numerical methods herein presented, the integration process (see Eq. \eqref{eq:general_integral}) is the same, only the integration points and weights change. Using this, the integration evaluation is implemented in the Integrate method, shown in Code \ref{code:Integrate}.
\begin{lstlisting}[language=python, caption={Integrate Method.}, label={code:Integrate}]
def Integrate(self, func: callable, a: float, b: float, n_points: int)->float:
    self.IntegrationPoints(a, b, n_points)
    
    integral = 0.0
    for point, weight in zip(self.points, self.weights):
        self.ComputeRequiredData(point, a, b)

        integral += self.detJac * func(self.Xmapped) * weight 
    return integral
\end{lstlisting}

The function ComputeRequiredData, in line 6, is responsible for computing the mapping of the integration points to the interval, and the Jacobian determinant. Again, it is emphasized the fact that the Simpsons and Trapezoidal rules do not have a Jacobian determinant, but the method name is kept for consistency. Instead, it is used the constant that multiplies the sum of the function evaluations. 

\subsection{SimpsonOneThirdRule Class}
The SimpsonOneThirdRule class (Code \ref{code:SimpsonOneThirdRule}) is where the method is properly developed. It inherits from the IntegrationRule class, and the methods IntegrationPoints, Xmap, and DetJac are implemented.
\begin{lstlisting}[language=python, caption={SimpsonOneThirdRule Class.}, label={code:SimpsonOneThirdRule}]
from IntegrationRule import IntegrationRule

@dataclass 
class SimpsonOneThirdRule(IntegrationRule):
    def IntegrationPoints(self, a: float, b: float, _)->None:
        self.points = [a, (a+b)/2, b]
        self.weights = [1/3, 4/3, 1/3]

    def Xmap(self, xi: float, _, __)->None:
        self.Xmapped = xi

    def DetJac(self, a: float, b: float)->float:
        self.detjac = (b - a) / 2
\end{lstlisting}

In line 5, the third argument passed to the function is not used, the reason why it is written as an underscore. Note that by using the points and weights as implemented, the final equation for the Simpson's 1/3 rule is in concordance with Eq. \eqref{eq:simpson_1_3}. 

In this rule, there is no mapping function, that is why the Xmap returns the same value as the input. For the same reason, the DetJac returns the multiplication constant for the rule.


\subsection{SimpsonThreeEighthsRule Class}
Simarly to the SimpsonOneThirdRule class, the SimpsonThreeEighthsRule class (Code \ref{code:SimpsonThreeEighthsRule}) is implemented.
\begin{lstlisting}[language=python, caption={SimpsonThreeEighthsRule Class.}, label={code:SimpsonThreeEighthsRule}]
from IntegrationRule import IntegrationRule

@dataclass
class SimpsonThreeEighthsRule(IntegrationRule):
    def IntegrationPoints(self, a: float, b: float, _) -> None:
        self.points = [a, (2* a + b) / 3, (a + 2 * b) / 3, b]
        self.weights = [1/8, 3/8, 3/8, 1/8]

    def Xmap(self, xi: float, _, __) -> None:
        self.Xmapped = xi

    def DetJac(self, a: float, b: float)-> float:
        self.detjac = (b - a)
\end{lstlisting}

\subsection{TrapezoidalRule Class}
The TrapezoidalRule class (Code \ref{code:TrapezoidalRule}) is implemented in the same way as the previous classes.
\begin{lstlisting}[language=python, caption={TrapezoidalRule Class.}, label={code:TrapezoidalRule}]
from IntegrationRule import IntegrationRule

@dataclass
class TrapezoidalRule(IntegrationRule):
    def IntegrationPoints(self, a: float, b: float, _)->None:
        self.points = [a, b]
        self.weights = [1/2, 1/2]

    def Xmap(self, xi: float, _, __)->None:
        self.Xmapped = xi

    def DetJac(self, a: float, b: float)->float:
        self.detjac = (b - a)
\end{lstlisting}

\subsection{GaussLegendreRule Class}
The last class implemented in this work. The main difference between the GaussLegendreRule (Code \ref{code:GaussLegendreRule}) and the others is the existence of a mapping function and a Jacobian determinant. 

The number of points is a parameter for the IntegrationPoints method, which defines the points and weights to be used during the integration.
\begin{lstlisting}[language=python, caption={GaussLegendreRule Class.}, label={code:GaussLegendreRule}]
from IntegrationRule import IntegrationRule

@dataclass
class GaussLegendreRule(IntegrationRule):
    def IntegrationPoints(self, _, __, npoints: int) -> None:
        match npoints:
            ...
            case 4:
                self.weights.append(0.2369268850561891)
                self.weights.append(0.4786286704993665)
                self.weights.append(0.5688888888888889)
                self.weights.append(0.4786286704993665)
                self.weights.append(0.2369268850561891)
                
                self.points.append(-0.9061798459386640)
                self.points.append(-0.5384693101056831)
                self.points.append(0)
                self.points.append(0.5384693101056831)
                self.points.append(0.9061798459386640)

            case _:
                raise ValueError("Invalid number of points")
            
    def Xmap(self, xi: float, a: float, b: float) -> None:
        self.Xmapped = a * (1 - xi) / 2 + b * (1 + xi) / 2

    def DetJac(self, a: float, b: float) -> float:
        self.detjac = (b - a) / 2
\end{lstlisting}

Herein is shown the implementation for the four-point Gauss-Legendre rule, but the three dots on the top indicates the points and weights for 1, 2, and 3 points rules. The weights and points are defined in lines 9 to 19. The mapping function is implemented in line 24, and the Jacobian determinant in line 27.

With these classes implemented, the numerical integrations can be executed. The following section presents the results obtained during this work.  