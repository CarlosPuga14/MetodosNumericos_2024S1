\section{The Full Matrix Class}\label{sec:fullmatrix}
The FullMatrix class is developed to store and manipulate dense matrices. The class is implemented in Python and has as methods the basic constructor, the SetDecompositionMethod, RankOneUpdtade, Fill\_L, Fill\_U, Fill\_D, Pivot, Lu\_Decompostion, LDLT\_Decompostion, FindInverse, and Decompose. Each one of these methods is described in the following sections. 

The main goal of this class is to decompose a given matrix and compare not only if the decomposition could be done, but whether the decomposition is correct. The inverse of the matrix is calculated as a way to check the accuracy of the code. 
\subsection{Class Implementation} \label{sec:fullmatrix_implementation}
The class FullMatrix has the following attributes: 
\begin{lstlisting}[language=Python, caption={FullMatrix constructor.}, label={code:main}] 
@dataclass
class FullMatrix:
    tolerance: ClassVar[float] = 1e-11 # Tolerance for the decomposition

    A: np.array # Matrix
    pivoting: bool = False # Pivoting flag
    diagonal: bool = False # Diagonal flag
    decomposition_type: str = None # Decomposition type
    size: int = field(init=False) # Matrix size

    A_Decomposed: np.array = field(init=False) # Decomposed matrix
    L: np.array = field(init=False) # Lower matrix
    U: np.array = field(init=False) # Upper matrix
    D: np.array = field(init=False) # Diagonal matrix

    detA: float = field(init=False) # Determinant of A
    inverseA: np.array = field(init=False) # Inverse of A
    decomposed_inverse: np.array = field(init=False) # Inverse of A by decomposition

    permuted_rows: list = field(default_factory=list) # permuted rows
    permuted_cols: list = field(default_factory=list) # permuted columns

    A_Memory: int = field(init=False, default=0) # Memory usage of the matrix
\end{lstlisting}

Among the attributes, the most important ones are the matrix A, which storages the full matrix itself, the decomposition\_type, responsible for setting which type of decomposition will be used, A\_Decomposed, which stores the decomposed matrix, L, D, and U, which stores the lower, diagonal and upper decomposed matrices. Notice that regardless of the method, a diagonal matrix is always created but initialized as an Identity matrix. 

One cites as well the permutation\_rows and permutations\_cols attributes, which are used during the pivoting process. The A\_Memory attribute stores how much memory is used by the matrix and will be used for further comparisons between full and sparse matrices. 

The first method that is implemented is the Decompose method. This function performs the decomposition depending on the decomposition\_type attribute. The method is shown in Listing \ref{code:decompose}.
\begin{lstlisting}[language=Python, caption={Decompose method.}, label={code:decompose}]
def Decompose(self)->None:
    if self.CheckSingularity():
        raise Exception("Singular matrix")
    
    if not self.Check_Symmetry() and (self.decomposition_type == "LDLt"):
        raise Exception("Matrix not symmetric.")
    
    if self.pivoting:
        self.Pivot_Decomposition()

    elif self.decomposition_type == "LU":
        self.LU_Decomposition()

    elif self.decomposition_type == "LDLt":
        self.LDLt_Decomposition()

    else:
        text = f"The '{self.decomposition_type}' decomposition is not valid. Please choose one of the following: LU, LDLt "
        raise Exception(text)
\end{lstlisting}
In line 2, the method checks if the matrix is singular. If it is, an exception is raised since the decomposition cannot be done. Line 5 checks if the matrix is symmetric once the LDLt is only valid for symmetric matrices. If the matrix is not symmetric, an exception is raised. Finally, in line 8 the decomposition is performed according to the decomposition\_type attribute. If the decompostion type does not match any of the implemented methods, an exception is raised.

Due to their simplicity, LU\_Decompostion and LDLt\_Decompostion methods are not shown first. Concepts like RankOneUpdate and Fill\_L, Fill\_U, and Fill\_D are explained in the following sections. Then, the Pivot\_Decomposition method is commented. 

From the implementation standpoint, both LU and LDLt implementations are alike. Basically what is done is to subtract each equation from the submatrix below it, updating the matrix using the rank one update method. Code \ref{code:decompostion} shows the main idea of the decomposition methods.
\begin{lstlisting}[language=Python, caption={Decomposition method.}, label={code:decompostion}]
def LU_Decomposition(self)->None:
    self.RankOneUpdate()
    self.Fill_L()
    self.Fill_U()

def LDLt_Decomposition(self)->None:
    self.RankOneUpdate()
    self.Fill_L()
    self.Fill_D()
    self.U = self.L.T
\end{lstlisting}

Comparing both methods in Code \ref{code:decompostion}, one realizes that the class is implemented in a manner to avoid code repetition. The only difference is that the LDLt method fills the diagonal matrix D with the Fill\_D method and the U matrix is the transpose of the L matrix. Code \ref{code:rankoneupdate} shows the RankOneUpdate method adapted for both LU and LDLt decompositions.
\begin{lstlisting}[language=Python, caption={RankOneUpdate method.}, label={code:rankoneupdate}]
def RankOneUpdate(self)->None:
    for i in range(self.size):
        matii_correction = 1.0

        if (abs(self.A_Decomposed[i, i]) < self.tolerance):
            raise Exception("Null Pivot")

        if self.decomposition_type in == "LDLt":
            matii_correction = self.A_Decomposed[i, i]
            self.A_Decomposed[i, i+1::] /= self.A_Decomposed[i, i]

        self.A_Decomposed[i+1::, i] /= self.A_Decomposed[i, i]
        self.A_Decomposed[i+1::, i+1::] -= OUTER(self.A_Decomposed[i+1::, i], self.A_Decomposed[i, i+1::]) * matii_correction
\end{lstlisting}

The main difference between the Lu and LDLt rank one update is that, for the former only the column below the pivot is updated, while for the latter both row and column are updated. Due to this fact, for LDLt it is necessary to correct the value of the submatrix formed by the outer product of the row and column vectors (matii\_correction = A\_Decomposed[i, i], rather than 1).

Line 5 raises the issue when the pivot is null. Since the row and column are divided by it, the rank one update is not possible. To overcome this problem, the Pivot method is implemented. The Pivot\_Decompostion method is shown in Code \ref{code:pivotdecomp}.
\begin{lstlisting}[language=Python, caption={Pivot method.}, label={code:pivotdecomp}]
def Pivot_Decomposition(self)->None:
    for index in range(self.size - 1):
        self.Pivot(index)
        
        if (abs(self.A_Decomposed[index, index]) < self.tolerance):
            raise Exception("Null Pivot.")

        matii_correction = 1.0

        if self.decomposition_type == "LDLt":
            matii_correction = self.A_Decomposed[index, index]
            self.A_Decomposed[index, index+1::] /= self.A_Decomposed[index, index]

        self.A_Decomposed[index+1::, index] /= self.A_Decomposed[index, index]
        self.A_Decomposed[index+1::, index+1::] -= OUTER(self.A_Decomposed[index+1::, index], self.A_Decomposed[index, index+1::]) * matii_correction

    self.Fill_L()
    if self.decomposition_type == "LU":
        self.Fill_U()

    elif self.decomposition_type == "LDLt":
        self.Fill_D()
        self.U = self.L.T

    self.permuted_rows = self.PermutationMatrix(self.permuted_rows)
    self.permuted_cols = self.PermutationMatrix(self.permuted_cols, rows=False)
\end{lstlisting}

Notice that the rank one update is now evaluated in each iteration to find the pivot, instead of from start to beginning. This ensures that the pivoting will guarantee the convergence of the decomposition method. Line 6 shows the Pivot method being called (see Code \ref{code:pivot}). Lines 11 - 19 evaluate the rank one updated. Lines 20 - 26 fill the matrices L, D, and U. Finally, lines 28 and 29 create the permutation matrices for rows and columns. 
\begin{lstlisting}[language=Python, caption={Pivot method.}, label={code:pivot}]
def Pivot(self, index:int)->None:
    rows = [i for i in range(self.size)]
    cols = [i for i in range(self.size)]

    submatrix = self.A_Decomposed[index::, index::].copy()

    row_max, col_max = self.FindMaxRowAndCol(submatrix)
    row_max += index
    col_max += index

    rows, cols = self.UpdatedPermutationVector(rows, cols, row_max, col_max, index)

    perm_row = self.PermutationMatrix(rows)
    perm_col = self.PermutationMatrix(cols, rows=False)

    self.A_Decomposed = perm_row @ self.A_Decomposed @ perm_col
\end{lstlisting}
The pivot method is simple and consists of finding the maximum value in the submatrix below the pivot to permute the rows and columns. Special attention is paid to the LDLt decomposition in which the maximum value is found in the diagonal to maintain the symmetry of the matrix. A flag, diagonal, can also be set to force the LU decomposition to look for the maximum value in the diagonal as well.

The Fill\_L, Fill\_U, and Fill\_D methods are simple and are shown in Code \ref{code:fill}.
\begin{lstlisting}[language=Python, caption={Fill\_L, Fill\_U, and Fill\_D methods.}, label={code:fill}]
def Fill_L(self)->None:
    for i in range(diagonal_aux1, self.size):
        for j in range(i + diagonal_aux2):
            self.L[i, j] = self.A_Decomposed[i, j]

def Fill_U(self)->None:
    diagonal_aux1 = 0 if self.decomposition_type == "LU" else 1 # row used to start filling the matrix
    diagonal_aux2 = 1 if self.decomposition_type == "LU" else 0 # column used to start filling the matrix

    for j in range(diagonal_aux1, self.size):
        for i in range(j + diagonal_aux2):
            self.U[i, j] = self.A_Decomposed[i, j]

def Fill_D(self)->None:
    for i in range(self.size):
        self.D[i, i] = self.A_Decomposed[i, i]
\end{lstlisting}

Lastly, the FindInverse method, used to compare the inverse of the original matrix and the one obtained after the decomposition, is shown in Code \ref{code:inverse}.
\begin{lstlisting}[language=Python, caption={FindInverse method.}, label={code:inverse}]
def FindInverse(self)->None:
    if self.pivoting:
        self.decomposed_inverse = self.permuted_rows.T @ INVERSE(self.U) @ INVERSE(self.D) @ INVERSE(self.L) @ self.permuted_cols.T
    
    elif self.decomposition_type in ["LU", "LDLt"]:
        self.decomposed_inverse = INVERSE(self.U) @ INVERSE(self.D) @ INVERSE(self.L)
    
    else:
        raise Exception(f"The '{self.decomposition_type}' decomposition is not valid.")
\end{lstlisting}

In the case of pivoting, the inverse is obtained by $pR^T.U^{-1}.D^{-1}.L^{-1}.pC^T$. However, if no pivoting has been done, the inverse is simply $U^{-1}.D^{-1}.L^{-1}$. If the decomposition type is not valid, an exception is raised.

\subsection{Matrix LU Decomposition} \label{sec:lu}

\subsection{Matrix LDLt Decomposition} \label{sec:ldlt}