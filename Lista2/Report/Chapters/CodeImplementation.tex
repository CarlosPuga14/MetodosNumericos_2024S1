\section{Code Implementation} \label{sec:code-implementation}
In this section, a brief explanation of how the numerical methods for integration are implemented. The code is written in Python, and a total of six classes are developed, besides the file containing the main function. Although parts of the code are presented here, the complete code is available on the GitHub repository, available in the Appendix \ref{sec:github}.

\subsection{Main File}
The main function is written in the \texttt{main.py} file. This file is responsible for structuring the code, creating objects for numerical integration analysis. An example of implementation for the main file is shown in Code \ref{code:main}.
\begin{lstlisting}[language=Python, caption={Main function.}, label={code:main}] 
def main():
    n_divisions = 2
    npoints = 4
    interval = Interval(0.0, 1.0, n_divisions, npoints)

    # defining the refinement level
    ref_level = 2

    # defining the function and its exact solution
    p = 1
    func = lambda x: x ** p
    exact = lambda x: 1/(p + 1) * x ** (p + 1)

    # setting the integration rule
    interval.SetGaussLegendreRule()

    # integrating the function
    interval.NumericalIntegrate(func, ref_level)
    
    # computing the error
    interval.SetExactSolution(exact, ref_level)
    interval.ComputeError()

    return 0
\end{lstlisting}

It is emphasized that this is just a simple example. In line 1 the Interval class is imported, and in line 7 an object of this class is created. As input data, it takes the limits of the interval (in this case $0$ and $1$), the number of divisions, and the number of integration points. 

A function to be integrated is then defined, here is shown the polynomial $x$, and its exact solution, $0.5x^2$. The integration rule is set in line 18, and the function is integrated in line 21. In this example, it is used the Gauss-Legendre integration rule. 

The exact solution is set in line 24, and the error is computed in line 25. The results can also be printed in a \texttt{.txt} file, which is not presented here. The next sections will present, in more detail, the classes devloped in this project.

\subsection{The Interval Class}
The Interval class was developed by the Ph.D. Giovane Avancini. However, a few modifictations were made to adapt it to the project. This is the main class of this work, responsible for dealing with the interval data structure and computing the numerical integration.

The fields from the Interval class are shown in Code \ref{code:Interval_fields}. Notice that, since the dataclass decorator is used, the fields are automatically initialized in the constructor, not being necessary to define it explicitly.
\begin{lstlisting}[language=python, caption={Interval class fields.}, label={code:Interval_fields}]
from dataclasses import dataclass

@dataclass
class Interval:
    _a: float
    _b: float
    _n_refinements: int
    _refinement_level: int = field(default=0)
    _n_points: int = field(default=0)
    _method: IntegrationRule = field(init=False, default=None)
    _sub_intervals: list = field(init=False, default_factory=list)
    _numerical_integral: float = field(init=False, default=0.0)
    _analytic_integral: float = field(init=False, default=0.0)
    _integration_error: float = field(init=False, default=0.0)
\end{lstlisting}

The floats $a$ and $b$ represents the integration interval, $n\_refinement$ is the number of refinements that is going to be made, and ${refinement\_level}$ is the current interval refinement level. The $n\_points$ is the number of points used in the numerical integration (mostly used in the Gauss-Legendre rule). 

From the $method$ field on, the fields are not initialized at the moment of the object creation, which explains the \texttt{init=False} argument. The $method$ field is an object from the IntegrationRule class, $sub\_intervals$ is a list that might contain the interval subdivisions, $numerical\_integral$ is the result of the numerical integration, $analytic\_integral$ is the exact solution, and the error between the numerical and the exact solution is stored in $integration\_error$.

Among the methods of the Interval class, one stands out: the NumericalIntegrate method. This method is responsible for computing the numerical integration of a given function. The code for this method is shown in Code \ref{code:NumericalIntegrate}. 
\begin{lstlisting}[language=python, caption={NumericalIntegrate Method.}, label={code:NumericalIntegrate}]
def NumericalIntegrate(self, func: callable, ref_level: int = 0)->float:
    self.numerical_integral = 0.0
    if self.refinement_level == ref_level:
        self.numerical_integral = self.method.Integrate(func, self.a, self.b, self.n_points)
    else:
        for interval in self.sub_intervals:
            self.numerical_integral += interval.NumericalIntegrate(func, ref_level)

    return self.numerical_integral
\end{lstlisting}

Line 3 checks if the current interval is the one that the numerical integration is going to be computed. If it is, the method Integrate from the IntegrationRule class is called. Otherwise, the method is called recursively for each subinterval.

Finally, the ComputeError method (Code \ref{code:ComputeError}) is responsible for computing the error between the numerical and the exact solution.
\begin{lstlisting}[language=python, caption={ComputeError Method}, label={code:ComputeError}]
def ComputeError(self)->float:
    self.integration_error = abs(self.numerical_integral - self.analytic_integral)

    interval: Interval
    for interval in self.sub_intervals:
        interval.ComputeError()
    return self.integration_error
\end{lstlisting}

\subsection{The IntegrationRule Class}
The IntegrationRule class is what it's called an \textit{abstract class}. It is a class that cannot be instantiated, but it is used as a base class for other classes. In this case, it is used as a base class for the numerical integration rules. 

As its abstract methods, one can cite the IntegrationPoints method, in which the integration points are computed, the Xmap method, which maps the integration points to the interval, and the DetJac method, which computes the Jacobian determinant. An observation is made at this point. The methods' name might not be appropriate for the one-third and three-eighths Simpson, and the Trapezoidal rules. However, the names come from the usually employed in Gauss-Legendre implementations. 

This class takes in advantage the fact that, for all numerical methods herein presented, the integration process (see Eq. \eqref{eq:numInt}) is the same, only the integration points and weights change. Using this, the integration process is implemented in the Integrate method, shown in Code \ref{code:Integrate}.
\begin{lstlisting}[language=python, caption={Integrate Method.}, label={code:Integrate}]
def Integrate(self, func: callable, a: float, b: float, n_points: int)->float:
    self.IntegrationPoints(a, b, n_points)
    
    integral = 0.0
    for point, weight in zip(self.points, self.weights):
        self.ComputeRequiredData(point, a, b)

        integral += self.detJac * func(self.Xmapped) * weight 
    return integral
\end{lstlisting}

\subsection{The SimpsonOneThirdRule Class}

\subsection{The SimpsonThreeEighthsRule Class}

\subsection{The TrapezoidalRule Class}

\subsection{The GaussLegendreRule Class}